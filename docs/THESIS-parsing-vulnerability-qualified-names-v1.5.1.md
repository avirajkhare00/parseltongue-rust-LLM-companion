# Parsing Vulnerability Thesis: Qualified Name Key Format Issues

## v1.5.1 Pre-Release Analysis | February 2026

---

## TL;DR (The Simple Version)

**The Problem**: Parseltongue uses `:` to separate parts of entity keys. But C++, C#, Ruby, and Rust use `::` in their code. When we put `::` inside a key that uses `:` as a separator, the key breaks.

**Analogy**: It's like trying to store a filename with `/` on Linux. The system uses `/` to separate folders, so `my/file.txt` becomes three things (`my`, `file`, `txt`) instead of one filename.

---

## Part 1: The Foundation

### What is an ISGL1 Key?

Every code entity (function, class, method) gets a unique identifier called an ISGL1 key:

```
rust:fn:main:__src_main:T1234567890
 │    │   │       │          │
 │    │   │       │          └── Birth timestamp (when entity was first seen)
 │    │   │       └── Semantic path (file location, sanitized)
 │    │   └── Entity name (the function/class name)
 │    └── Entity type (fn, class, struct, etc.)
 └── Programming language
```

**The Rule**: Split by `:` and you get exactly 5 parts.

### What Goes Wrong?

Some languages use `::` in their syntax:

```cpp
std::vector<int> items;    // C++ namespace
```

```csharp
global::System.DateTime    // C# global qualifier
```

```ruby
ActiveRecord::Base         // Ruby module path
```

When we create a key for `std::vector`:

```
cpp:fn:std::vector:unresolved-reference:0-0
```

Split by `:` gives us **7 parts**, not 5:
1. `cpp`
2. `fn`
3. `std`
4. `` (empty!)
5. `vector`
6. `unresolved-reference`
7. `0-0`

**The parser expects 5 parts. It gets 7. It fails.**

---

## Part 2: ELI5 - Why This Matters

### The Library Card Analogy

Imagine a library where every book has a card with 5 fields:

```
[Section] : [Shelf] : [Book Name] : [Author] : [Year]
```

This works great:
```
Fiction : A3 : Harry Potter : Rowling : 1997
```

But what if someone writes a book called "War : Peace"?

```
Fiction : A3 : War : Peace : Tolstoy : 1869
```

Now you have **6 fields** instead of 5. The librarian's system breaks:
- It thinks "Peace" is the author
- It thinks "Tolstoy" is the year
- "1869" is... extra?

**Result**: The library system can't find the book. It exists on the shelf, but the card catalog is corrupted.

### In Parseltongue Terms

- **Book** = Code entity (function, class)
- **Card** = ISGL1 key
- **Catalog** = CozoDB database
- **Finding the book** = Blast radius queries, dependency tracking

When keys are malformed:
- Edges point to entities that "don't exist" (orphaned edges)
- Queries return incomplete results
- The dependency graph has holes

---

## Part 3: Which Languages Are Affected?

### Severity Levels Explained

| Severity | Meaning | User Impact |
|----------|---------|-------------|
| **HIGH** | `::` is fundamental to the language | 30-80% of edges could be broken |
| **MEDIUM** | Edge cases with special characters | 5-15% of edges affected |
| **LOW** | No problematic characters | Minimal to zero impact |

### Language-by-Language Breakdown

#### HIGH Severity (Must Fix)

| Language | Character | Example | Why It's Used |
|----------|-----------|---------|---------------|
| **C++** | `::` | `std::vector` | Namespace scoping (used EVERYWHERE) |
| **C#** | `::` | `global::System` | Disambiguation from local types |
| **Ruby** | `::` | `ActiveRecord::Base` | Module/class hierarchy |
| **Rust** | `::` | `std::collections::HashMap` | Module paths |

#### MEDIUM Severity (Should Fix)

| Language | Character | Example | Why It's Used |
|----------|-----------|---------|---------------|
| **PHP** | `\` | `\App\Models\User` | Namespace separator |
| **TypeScript** | `<>` | `Array<string>` | Generic types |
| **Java** | `<>` | `List<String>` | Generic types |

#### LOW Severity (Already Safe)

| Language | Why Safe |
|----------|----------|
| **Python** | Uses `.` for modules (already sanitized) |
| **JavaScript** | Uses `.` for objects (already sanitized) |
| **Go** | Uses `/` for packages (already sanitized) |
| **C** | No namespace syntax |

---

## Part 4: Real-World Impact Assessment

### The Math

For a typical C++ codebase:

```
1 million lines of code
├── ~50,000 function calls
├── ~70% use namespace prefixes (std::, boost::, etc.)
├── = 35,000 calls with "::"
└── = 35,000 BROKEN EDGES
```

### What "Broken" Actually Means

```
┌─────────────────────────────────────────────────────────┐
│                    DEPENDENCY GRAPH                      │
├─────────────────────────────────────────────────────────┤
│                                                          │
│   [main.cpp]                                             │
│       │                                                  │
│       ├──calls──> [std::vector]  ← EXISTS as edge       │
│       │                ↓                                 │
│       │           [NO ENTITY]    ← Placeholder FAILED   │
│       │                                                  │
│       └──calls──> [my_function]  ← Works fine           │
│                        ↓                                 │
│                   [ENTITY]       ← Placeholder created   │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

**Consequence**: When you ask "what does main.cpp depend on?", you only see `my_function`. The `std::vector` dependency is invisible.

### Query Impact Table

| Query Type | What Happens | User Experience |
|------------|--------------|-----------------|
| **Blast Radius** | Stops at orphaned edges | "Only 5 files affected" (actually 50) |
| **Reverse Callers** | Missing callers | "Nobody calls this" (wrong) |
| **Dependency Count** | Undercount | "Low coupling" (actually high) |
| **Graph Visualization** | Disconnected nodes | Confusing, incomplete picture |

---

## Part 5: Technical Deep Dive

### Where Keys Are Generated

**File**: `crates/parseltongue-core/src/query_extractor.rs`

```rust
// Lines 668-672 - THE BUG LOCATION
let to_key = format!(
    "{}:fn:{}:unresolved-reference:0-0",
    language,
    to  // ← 'to' contains "std::vector" with "::"
);
```

The `to` variable comes directly from tree-sitter without sanitization:

```rust
// Lines 577-580
if capture_name.starts_with("reference.") {
    to_name = Some(node_text.to_string());  // Raw text, includes "::"
}
```

### Where Keys Are Parsed

**File**: `crates/pt01-folder-to-cozodb-streamer/src/external_dependency_handler.rs`

```rust
// Lines 207-219 - THE VALIDATION THAT FAILS
let parts: Vec<&str> = key.split(':').collect();

if parts.len() != 5 {
    return Err(StreamerError::ParsingError {
        reason: format!(
            "Expected 5 parts in external dependency key, got {}: {}",
            parts.len(),
            key
        ),
    });
}
```

### The Data Flow

```
┌──────────────────┐
│  Source Code     │  std::vector<int> items;
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│  Tree-sitter     │  Captures "std::vector" (raw text)
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│  query_extractor │  Creates key: "cpp:fn:std::vector:..."
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│  Database        │  Stores edge with malformed to_key
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│  external_dep    │  Tries to parse key → FAILS
│  _handler        │  (7 parts instead of 5)
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│  Result          │  Warning printed, NO PLACEHOLDER CREATED
└──────────────────┘
```

---

## Part 6: Affected Tree-Sitter Queries

### C++ (`dependency_queries/cpp.scm`)

```scheme
; Line 60-62: Qualified type declarations
(declaration
  type: (qualified_identifier) @reference.qualified_type)
; Captures "std::string" with "::"

; Line 70: Smart pointer calls
(call_expression
  function: (qualified_identifier) @reference.smart_pointer)
; Captures "std::make_unique" with "::"
```

### C# (`dependency_queries/c_sharp.scm`)

```scheme
; Line 13: Using directives
(using_directive (qualified_name) @reference.using)
; Could capture "global::System.Resources" with "::"

; Lines 29-35: Object creation
(object_creation_expression
  type: [(qualified_name) @reference.constructor_qualified])
; Could capture qualified names with "::"
```

### Ruby (`dependency_queries/ruby.scm`)

```scheme
; Lines 38-42: Constructor calls with modules
(call
  receiver: (scope_resolution
    name: (constant) @reference.constructor_qualified)
  method: (identifier) @_new_qualified)
; Captures "Models::User" with "::"
```

### Rust (`dependency_queries/rust.scm`)

```scheme
; Line 40: Full use paths
(scoped_identifier) @reference.use_full_path
; Captures "clap::Parser" with "::"

; Line 24: Scoped calls
(scoped_identifier name: (identifier) @reference.call)
; Captures "std::io::stdout" with "::"
```

---

## Part 7: Solution Options

### Option 1: Sanitize at Capture Time (Recommended)

```rust
fn sanitize_name_for_isgl1_key(name: &str) -> String {
    name.replace("::", "__")  // C++, C#, Ruby, Rust
        .replace("\\", "_")   // PHP namespaces
        .replace("<", "_")    // Generics
        .replace(">", "_")
}
```

**Pros**: Simple, one place to fix
**Cons**: Information loss (can't reverse `__` to `::`)

### Option 2: Change ISGL1 Delimiter

Use `|` instead of `:`:

```
cpp|fn|std::vector|unresolved-reference|0-0
```

**Pros**: No conflict with any language
**Cons**: Breaking change, migration needed

### Option 3: Escape Colons

Use `\:` for literal colons:

```
cpp:fn:std\:\:vector:unresolved-reference:0-0
```

**Pros**: Reversible, no information loss
**Cons**: Complex parsing logic

### Option 4: Structured Format

Use JSON or similar:

```json
{"lang":"cpp","type":"fn","name":"std::vector","path":"unresolved-reference","lines":"0-0"}
```

**Pros**: Flexible, extensible
**Cons**: Verbose, performance impact

---

## Part 8: Estimated Impact by Codebase Type

| Codebase Type | Language Mix | Broken Edge % | Quality Impact |
|---------------|--------------|---------------|----------------|
| Web Frontend | JS/TS only | ~0% | None |
| Python Backend | Python only | ~0% | None |
| Go Microservices | Go only | ~0% | None |
| Java Enterprise | Java + some C++ | 5-10% | Minor |
| Game Engine | C++ heavy | 60-80% | **Critical** |
| .NET Application | C# with global:: | 10-20% | Moderate |
| Rails Application | Ruby | 20-40% | Significant |
| Systems (Rust) | Rust | 30-50% | Significant |
| Mixed Monorepo | All languages | 20-40% | Significant |

---

## Part 9: Conclusion

### The Core Problem

ISGL1 key format uses `:` as delimiter, but 4 major languages (C++, C#, Ruby, Rust) use `::` in their syntax. This creates a fundamental incompatibility.

### The Impact

- **For Python/JS/Go users**: No impact
- **For C++/C#/Ruby/Rust users**: Significant data quality issues
- **For mixed codebases**: Partial graph, unreliable queries

### The Fix Required

Before v1.5.1 release, implement sanitization for all `::` occurrences in entity names before key generation.

### Priority

**HIGH** - This affects core functionality for 4 out of 12 supported languages.

---

## Appendix: Test Cases Needed

```rust
#[test]
fn test_cpp_namespace_sanitization() {
    // Input: "std::vector"
    // Expected key: "cpp:fn:std__vector:unresolved-reference:0-0"
}

#[test]
fn test_csharp_global_sanitization() {
    // Input: "global::System.Resources.ResourceManager"
    // Expected key: "csharp:fn:global__System.Resources.ResourceManager:..."
}

#[test]
fn test_ruby_module_sanitization() {
    // Input: "ActiveRecord::Base"
    // Expected key: "ruby:class:ActiveRecord__Base:..."
}

#[test]
fn test_rust_path_sanitization() {
    // Input: "std::collections::HashMap"
    // Expected key: "rust:module:std__collections__HashMap:..."
}

#[test]
fn test_php_namespace_sanitization() {
    // Input: "\App\Models\User"
    // Expected key: "php:class:_App_Models_User:..."
}
```

---

*Document Version: 1.0*
*Analysis Date: February 7, 2026*
*Prepared for: v1.5.1 Pre-Release Review*
